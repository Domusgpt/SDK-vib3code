<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quatossian Inscription Framework - Demo v2.1</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 16, 0.9);
            padding: 20px;
            border-radius: 4px;
            width: 320px;
            border: 1px solid #334455;
            box-shadow: 0 0 30px rgba(0, 100, 255, 0.1);
            backdrop-filter: blur(5px);
        }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; color: #88aaff; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #4a9eff; }
        select { width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #334455; border-radius: 2px; font-family: inherit; font-size: 12px; }
        button {
            background: linear-gradient(135deg, #224466, #112233);
            color: #4a9eff;
            border: 1px solid #334455;
            padding: 12px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }
        button:hover { background: #335577; box-shadow: 0 0 15px rgba(74, 158, 255, 0.2); border-color: #4a9eff; }
        .value { float: right; color: #fff; }
        h1 { margin: 0 0 20px 0; font-size: 14px; border-bottom: 1px solid #334455; padding-bottom: 10px; color: #4a9eff; letter-spacing: 2px; }
        .status { font-size: 10px; color: #556677; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>QUATOSSIAN FRAMEWORK</h1>

        <div class="control-group">
            <label>Lattice Projection Mode</label>
            <select id="renderMode">
                <option value="e8_cloud">E8 Lattice (Quatossian Cloud)</option>
                <option value="moxness">Moxness Folding (4D Slice)</option>
                <option value="plastic">Plastic Ratio (Reference)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Lattice Density (Shells) <span id="countVal" class="value">20</span></label>
            <input type="range" id="shells" min="1" max="50" step="1" value="20">
            <div class="status">Points: <span id="pointCount">4800</span> (Shells * 240)</div>
        </div>

        <div class="control-group">
            <label>Moiré Interference <span id="moireVal" class="value">30.0</span></label>
            <input type="range" id="moire" min="0" max="100.0" step="1.0" value="30.0">
        </div>

        <div class="control-group">
            <label>Kirigami Shift <span id="shiftVal" class="value">0.1</span></label>
            <input type="range" id="shift" min="0.0" max="1.0" step="0.01" value="0.1">
        </div>

        <button id="exportBtn">Export to Parserator (JSOH)</button>
        <div id="log" class="status" style="color: #88ff88; min-height: 15px;"></div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- INLINED CORE MATH (From src/math/E8.js and Plastic.js) ---

        const PLASTIC_CONSTANT = 1.324717957244746;
        const PHI = 1.61803398875;

        class E8Lattice {
            // Generate 240 Roots of E8
            static generateRoots() {
                const roots = [];
                // 1. Integer Roots (112): Permutations of (±1, ±1, 0^6)
                for (let j = 0; j < 8; j++) {
                    for (let k = j + 1; k < 8; k++) {
                        const signs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                        for (let s of signs) {
                            const v = new Float32Array(8);
                            v[j] = s[0]; v[k] = s[1];
                            roots.push(v);
                        }
                    }
                }
                // 2. Half-Integer Roots (128): (±0.5)^8 with even sum of signs
                for (let i = 0; i < 256; i++) {
                    let minusCount = 0;
                    let temp = i;
                    while(temp > 0) { if(temp & 1) minusCount++; temp >>= 1; }
                    if (minusCount % 2 === 0) {
                        const v = new Float32Array(8);
                        for(let b=0; b<8; b++) v[b] = ((i >> b) & 1) ? -0.5 : 0.5;
                        roots.push(v);
                    }
                }
                // Flatten
                const flat = new Float32Array(roots.length * 8);
                for(let i=0; i<roots.length; i++) flat.set(roots[i], i*8);
                return flat;
            }

            // Moxness Folding: 8D -> 4D (Left H4)
            static foldTo4D(v8) {
                const q = new Float32Array(4);
                // Standard E8->H4 fold: u = a + phi*b
                q[0] = v8[0] + PHI * v8[4];
                q[1] = v8[1] + PHI * v8[5];
                q[2] = v8[2] + PHI * v8[6];
                q[3] = v8[3] + PHI * v8[7];
                return q;
            }

            // Project 4D to 3D (Shadow)
            static project4Dto3D(q) {
                // Simple w-drop or perspective. Let's use 3D projection of the 4D point.
                // Scale factor to normalize visualization
                const f = 1.0;
                return new Float32Array([q[0]*f, q[1]*f, q[2]*f]);
            }

            // Generate "Quatossian Cloud": Positions + Rotations (Spin)
            static generateCloud(shells = 1) {
                const rootsFlat = this.generateRoots();
                const numRoots = 240;
                const count = numRoots * shells;

                const positions = new Float32Array(count * 3);
                const rotations = new Float32Array(count * 4);

                let idx = 0;
                for (let s = 0; s < shells; s++) {
                    // Plastic Scale expansion
                    const scale = Math.pow(PLASTIC_CONSTANT, s + 1) * 0.2; // Scale factor for viz

                    for (let i = 0; i < numRoots; i++) {
                        const v8 = rootsFlat.subarray(i*8, i*8+8);

                        // Spin State comes from the Folding
                        const q = this.foldTo4D(v8);

                        // Normalize q for rotation
                        const len = Math.sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
                        const qNorm = new Float32Array([q[0]/len, q[1]/len, q[2]/len, q[3]/len]);

                        rotations[idx*4+0] = qNorm[0];
                        rotations[idx*4+1] = qNorm[1];
                        rotations[idx*4+2] = qNorm[2];
                        rotations[idx*4+3] = qNorm[3];

                        // Position comes from the Fold projected to 3D * Shell Scale
                        // Note: We use the fold direction as the position vector
                        positions[idx*3+0] = q[0] * scale;
                        positions[idx*3+1] = q[1] * scale;
                        positions[idx*3+2] = q[2] * scale;

                        idx++;
                    }
                }
                return { positions, rotations };
            }
        }

        // --- RENDERER (From src/systems/PhillipsRenderer.js) ---

        class PhillipsRenderer {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl', { alpha: true, antialias: false });
                this.options = {
                    plasticScale: PLASTIC_CONSTANT,
                    backgroundColor: [0,0,0,1],
                    kirigamiShift: [0,0],
                    moireFreq: 20.0,
                    ...options
                };
                this.init();
            }

            init() {
                const gl = this.gl;

                // Vertex Shader with Rotation Attribute
                const vs = `
                    attribute vec3 a_position;
                    attribute float a_scale;
                    attribute vec3 a_color;
                    attribute vec4 a_rotation; // Quatossian Spin

                    uniform mat4 u_viewProjection;
                    uniform float u_plasticScale;

                    varying vec3 v_color;
                    varying vec2 v_screenPos;
                    varying vec4 v_rotation;

                    void main() {
                        vec4 pos = u_viewProjection * vec4(a_position, 1.0);
                        gl_Position = pos;

                        float dist = pos.w;
                        float size = (300.0 * a_scale * u_plasticScale) / dist;
                        gl_PointSize = max(2.0, size);

                        v_color = a_color;
                        v_rotation = a_rotation;
                        v_screenPos = pos.xy / pos.w;
                    }
                `;

                // Fragment Shader with Kirigami Interference
                const fs = `
                    precision mediump float;
                    uniform vec2 u_kirigamiShift;
                    uniform float u_moireFreq;

                    varying vec3 v_color;
                    varying vec2 v_screenPos;
                    varying vec4 v_rotation;

                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        float distSq = dot(coord, coord);
                        if (distSq > 0.25) discard;

                        // Extract Phase from Spin (w component + x tilt)
                        float spinPhase = v_rotation.w * 3.14 + v_rotation.x;

                        // Moiré Pattern
                        float g1 = sin((v_screenPos.x + v_screenPos.y) * u_moireFreq + spinPhase);
                        float g2 = sin((v_screenPos.x + v_screenPos.y + u_kirigamiShift.x) * (u_moireFreq * 1.05) + spinPhase);

                        float interference = 0.5 + 0.5 * (g1 * g2);

                        // "Diamond-Locked" look
                        vec3 finalColor = v_color * (0.6 + 0.8 * interference);
                        float alpha = 1.0 - smoothstep(0.20, 0.25, distSq);

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;

                const p = this.createProgram(gl, vs, fs);
                this.program = p;

                this.buffers = {
                    pos: gl.createBuffer(),
                    scale: gl.createBuffer(),
                    col: gl.createBuffer(),
                    rot: gl.createBuffer()
                };

                this.attribs = {
                    pos: gl.getAttribLocation(p, 'a_position'),
                    scale: gl.getAttribLocation(p, 'a_scale'),
                    col: gl.getAttribLocation(p, 'a_color'),
                    rot: gl.getAttribLocation(p, 'a_rotation')
                };

                this.uniforms = {
                    vp: gl.getUniformLocation(p, 'u_viewProjection'),
                    ps: gl.getUniformLocation(p, 'u_plasticScale'),
                    ks: gl.getUniformLocation(p, 'u_kirigamiShift'),
                    mf: gl.getUniformLocation(p, 'u_moireFreq')
                };

                this.resize();
            }

            createProgram(gl, vs, fs) {
                const compile = (t, s) => {
                    const shader = gl.createShader(t);
                    gl.shaderSource(shader, s);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(shader));
                    return shader;
                };
                const p = gl.createProgram();
                gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
                gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
                gl.linkProgram(p);
                return p;
            }

            setData(data) {
                const gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.pos);
                gl.bufferData(gl.ARRAY_BUFFER, data.positions, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.scale);
                gl.bufferData(gl.ARRAY_BUFFER, data.scales, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.col);
                gl.bufferData(gl.ARRAY_BUFFER, data.colors, gl.STATIC_DRAW);

                if (data.rotations) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.rot);
                    gl.bufferData(gl.ARRAY_BUFFER, data.rotations, gl.STATIC_DRAW);
                }
                this.count = data.positions.length / 3;
            }

            resize() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            render(vp) {
                if (!this.program) return;
                const gl = this.gl;
                this.resize();

                gl.clearColor(0.05, 0.05, 0.05, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.useProgram(this.program);

                const bind = (buf, loc, size) => {
                    if (loc !== -1) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                        gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(loc);
                    }
                };

                bind(this.buffers.pos, this.attribs.pos, 3);
                bind(this.buffers.scale, this.attribs.scale, 1);
                bind(this.buffers.col, this.attribs.col, 3);
                bind(this.buffers.rot, this.attribs.rot, 4);

                gl.uniformMatrix4fv(this.uniforms.vp, false, vp);
                gl.uniform1f(this.uniforms.ps, this.options.plasticScale);
                gl.uniform2fv(this.uniforms.ks, this.options.kirigamiShift);
                gl.uniform1f(this.uniforms.mf, this.options.moireFreq);

                gl.drawArrays(gl.POINTS, 0, this.count);
            }
        }

        // --- MAIN LOGIC ---

        const canvas = document.getElementById('canvas');
        const renderer = new PhillipsRenderer(canvas);
        let currentData = null;

        const state = {
            shells: 20,
            moire: 30.0,
            shift: 0.1,
            time: 0,
            mode: 'e8_cloud'
        };

        function generateData() {
            let positions, scales, colors, rotations;

            if (state.mode === 'e8_cloud') {
                const cloud = E8Lattice.generateCloud(state.shells);
                positions = cloud.positions;
                rotations = cloud.rotations;
                const count = positions.length / 3;

                scales = new Float32Array(count);
                colors = new Float32Array(count * 3);

                for(let i=0; i<count; i++) {
                    const shellIdx = Math.floor(i / 240);
                    scales[i] = 1.0 / Math.pow(PLASTIC_CONSTANT, (shellIdx % 5) + 1);

                    // Color from Spin (x,y,z)
                    colors[i*3] = (rotations[i*4] + 1)*0.5;
                    colors[i*3+1] = (rotations[i*4+1] + 1)*0.5;
                    colors[i*3+2] = (rotations[i*4+2] + 1)*0.5;
                }
                document.getElementById('pointCount').textContent = count;
            }
            else {
                // Placeholder for other modes (not implemented in this explicit demo)
                // Just use a single shell
                const cloud = E8Lattice.generateCloud(1);
                positions = cloud.positions;
                rotations = cloud.rotations;
                scales = new Float32Array(240).fill(1.0);
                colors = new Float32Array(240 * 3).fill(1.0);
            }

            currentData = { positions, scales, colors, rotations };
            renderer.setData(currentData);
        }

        // Animation Loop
        function loop() {
            state.time += 0.005;

            // Auto-shift Kirigami if not interacting
            const autoShift = [
                state.shift + Math.sin(state.time)*0.05,
                state.shift + Math.cos(state.time)*0.05
            ];
            renderer.options.kirigamiShift = autoShift;
            renderer.options.moireFreq = state.moire;

            // Simple Camera
            const aspect = canvas.width / canvas.height;
            const f = 1.0 / Math.tan(45 * Math.PI / 360); // 90 deg FOV
            const proj = new Float32Array([
                f/aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, -1, -1,
                0, 0, -0.2, 0
            ]);

            // Rotate Model
            const c = Math.cos(state.time * 0.5);
            const s = Math.sin(state.time * 0.5);
            const model = [
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, -4.0, 1 // Zoom out to see cloud
            ];

            // Multiply MVP (Simplified)
            const mvp = new Float32Array(16);
            // ... (standard matrix mult omitted for brevity, assuming WebGL handles standard layout)
            // Actually need to mult:
            // Manual mult:
            const a = proj; const b = model;
            for(let i=0; i<4; i++) {
                for(let j=0; j<4; j++) {
                    let sum = 0;
                    for(let k=0; k<4; k++) sum += a[k*4+j] * b[i*4+k]; // Column major
                    mvp[i*4+j] = sum;
                }
            }

            renderer.render(mvp);
            requestAnimationFrame(loop);
        }

        // UI
        document.getElementById('shells').oninput = (e) => {
            state.shells = parseInt(e.target.value);
            document.getElementById('countVal').textContent = state.shells;
            generateData();
        };
        document.getElementById('moire').oninput = (e) => {
            state.moire = parseFloat(e.target.value);
            document.getElementById('moireVal').textContent = state.moire;
        };
        document.getElementById('shift').oninput = (e) => {
            state.shift = parseFloat(e.target.value);
            document.getElementById('shiftVal').textContent = state.shift;
        };
        document.getElementById('exportBtn').onclick = () => {
             const json = JSON.stringify({
                 schema: "JSOH/2.0",
                 data: {
                     positions: Array.from(currentData.positions),
                     rotations: Array.from(currentData.rotations)
                 }
             });
             const blob = new Blob([json], {type:'application/json'});
             const url = URL.createObjectURL(blob);
             const link = document.createElement('a');
             link.href = url;
             link.download = 'quatossian.json';
             link.click();
        };

        generateData();
        loop();

        document.getElementById('log').textContent = "System Operational: Quatossian Kernel Active";
    </script>
</body>
</html>
