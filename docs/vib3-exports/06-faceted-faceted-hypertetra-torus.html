<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faceted Hypertetra Torus</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(100,255,150,0.3);
            border-radius: 8px;
            padding: 15px 20px;
            color: #fff;
            font-size: 12px;
            backdrop-filter: blur(10px);
            max-width: 320px;
        }
        .info h3 { color: #64ff96; margin-bottom: 8px; font-size: 14px; }
        .info p { opacity: 0.8; line-height: 1.4; margin-bottom: 8px; }
        .info .meta { font-size: 10px; opacity: 0.6; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; }
        .audio-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(100,255,150,0.3);
            border-radius: 8px;
            padding: 10px 15px;
            color: #64ff96;
            cursor: pointer;
            font-size: 12px;
        }
        .audio-btn:hover { background: rgba(100,255,150,0.2); }
    </style>
</head>
<body>
    <canvas id="vib3"></canvas>
    <div class="info">
        <h3>Faceted Hypertetra Torus</h3>
        <p>Hypertetrahedron-warped torus - creates complex toroidal structures through 5-cell projection</p>
        <div class="meta">
            System: FACETED<br>
            Geometry: 19 (Hypertetra)<br>
            VIB3+ Export â€¢ 1/26/2026
        </div>
    </div>
    <button class="audio-btn" onclick="toggleAudio()">ðŸŽµ Enable Audio</button>

    <script>
    // VIB3+ Exported Visualization
    // System: faceted
    // Generated: 2026-01-26T06:10:32.510Z

    const CONFIG = {
        system: 'faceted',
        geometry: 19,
        params: {
  "gridDensity": 18,
  "morphFactor": 1.6,
  "chaos": 0.2,
  "speed": 0.8,
  "hue": 45,
  "intensity": 0.85,
  "saturation": 0.8,
  "dimension": 3.5,
  "rot4dXY": 0,
  "rot4dXZ": 0,
  "rot4dYZ": 0,
  "rot4dXW": 1,
  "rot4dYW": 0.8,
  "rot4dZW": 1.2
},
        reactivity: {
  "audio": {
    "enabled": true,
    "sensitivity": 1.6
  }
}
    };

    const canvas = document.getElementById('vib3');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (!gl) {
        document.body.innerHTML = '<div style="color:#64ff96;padding:40px;text-align:center;"><h2>WebGL Required</h2><p>Please enable WebGL to view this visualization.</p></div>';
        throw new Error('WebGL not supported');
    }

    // Compile shaders
    function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader error:', gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    const vs = createShader(gl.VERTEX_SHADER, `
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}`);
    const fs = createShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_geometry;  // 0-23

            // 6D Rotation uniforms
            uniform float u_rot4dXY;
            uniform float u_rot4dXZ;
            uniform float u_rot4dYZ;
            uniform float u_rot4dXW;
            uniform float u_rot4dYW;
            uniform float u_rot4dZW;

            uniform float u_dimension;
            uniform float u_gridDensity;
            uniform float u_morphFactor;
            uniform float u_chaos;
            uniform float u_hue;
            uniform float u_intensity;

            // Audio reactivity (added for export)
            uniform float u_bass;
            uniform float u_mid;
            uniform float u_high;

            // 6 Rotation matrices for complete 4D rotation
            mat4 rotateXY(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                );
            }

            mat4 rotateXZ(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                );
            }

            mat4 rotateYZ(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    1, 0, 0, 0,
                    0, c, -s, 0,
                    0, s, c, 0,
                    0, 0, 0, 1
                );
            }

            mat4 rotateXW(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    c, 0, 0, -s,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    s, 0, 0, c
                );
            }

            mat4 rotateYW(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    1, 0, 0, 0,
                    0, c, 0, -s,
                    0, 0, 1, 0,
                    0, s, 0, c
                );
            }

            mat4 rotateZW(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, c, -s,
                    0, 0, s, c
                );
            }

            // Apply all 6 rotations
            vec4 apply6DRotation(vec4 pos) {
                pos = rotateXY(u_rot4dXY + u_time * 0.05) * pos;
                pos = rotateXZ(u_rot4dXZ + u_time * 0.06) * pos;
                pos = rotateYZ(u_rot4dYZ + u_time * 0.04) * pos;
                pos = rotateXW(u_rot4dXW + u_time * 0.07 + u_bass * 0.3) * pos;
                pos = rotateYW(u_rot4dYW + u_time * 0.08 + u_mid * 0.2) * pos;
                pos = rotateZW(u_rot4dZW + u_time * 0.09 + u_high * 0.25) * pos;
                return pos;
            }

            // Base geometry SDFs (0-7)
            float baseGeometry(vec4 p, float type) {
                if (type < 0.5) {
                    // Tetrahedron
                    return max(max(max(abs(p.x + p.y) - p.z, abs(p.x - p.y) - p.z),
                                   abs(p.x + p.y) + p.z), abs(p.x - p.y) + p.z) / sqrt(3.0);
                } else if (type < 1.5) {
                    // Hypercube
                    vec4 q = abs(p) - 0.8;
                    return length(max(q, 0.0)) + min(max(max(max(q.x, q.y), q.z), q.w), 0.0);
                } else if (type < 2.5) {
                    // Sphere
                    return length(p) - 1.0;
                } else if (type < 3.5) {
                    // Torus
                    vec2 t = vec2(length(p.xy) - 0.8, p.z);
                    return length(t) - 0.3;
                } else if (type < 4.5) {
                    // Klein Bottle (simplified)
                    float r = length(p.xy);
                    return abs(r - 0.7) - 0.2 + sin(atan(p.y, p.x) * 3.0 + p.z * 5.0) * 0.1;
                } else if (type < 5.5) {
                    // Fractal (Mandelbulb approximation)
                    return length(p) - 0.8 + sin(p.x * 5.0) * sin(p.y * 5.0) * sin(p.z * 5.0) * 0.2;
                } else if (type < 6.5) {
                    // Wave
                    return abs(p.z - sin(p.x * 5.0 + u_time) * cos(p.y * 5.0 + u_time) * 0.3) - 0.1;
                } else {
                    // Crystal
                    vec4 q = abs(p);
                    return max(max(max(q.x, q.y), q.z), q.w) - 0.8;
                }
            }

            // Hypersphere Core wrapper (8-15)
            float hypersphereCore(vec4 p, float baseType) {
                float baseShape = baseGeometry(p, baseType);
                float sphereField = length(p) - 1.2;
                return max(baseShape, sphereField);  // Intersection
            }

            // Hypertetrahedron Core wrapper (16-23)
            float hypertetrahedronCore(vec4 p, float baseType) {
                float baseShape = baseGeometry(p, baseType);
                float tetraField = max(max(max(
                    abs(p.x + p.y) - p.z - p.w,
                    abs(p.x - p.y) - p.z + p.w),
                    abs(p.x + p.y) + p.z - p.w),
                    abs(p.x - p.y) + p.z + p.w) / sqrt(4.0);
                return max(baseShape, tetraField);  // Intersection
            }

            // Main geometry dispatcher (0-23)
            float geometry(vec4 p, float type) {
                if (type < 8.0) {
                    // Base geometries (0-7)
                    return baseGeometry(p, type);
                } else if (type < 16.0) {
                    // Hypersphere Core (8-15)
                    return hypersphereCore(p, type - 8.0);
                } else {
                    // Hypertetrahedron Core (16-23)
                    return hypertetrahedronCore(p, type - 16.0);
                }
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);
                uv *= 2.0 / (u_gridDensity + u_bass * 5.0);

                // Create 4D point
                vec4 pos = vec4(uv, sin(u_time * 0.3) * 0.5, cos(u_time * 0.2) * 0.5);

                // Apply full 6D rotation
                pos = apply6DRotation(pos);

                // Apply morphing
                pos *= u_morphFactor + u_mid * 0.3;
                pos += vec4(sin(u_time * 0.1), cos(u_time * 0.15), sin(u_time * 0.12), cos(u_time * 0.18)) * (u_chaos + u_high * 0.2);

                // Get distance
                float dist = geometry(pos, u_geometry);

                // Faceted rendering (sharp edges)
                float edge = smoothstep(0.02, 0.0, abs(dist));
                float fill = smoothstep(0.1, 0.0, dist) * 0.3;

                // Color based on hue and distance
                float hueVal = u_hue / 360.0 + dist * 0.2 + u_time * 0.05 + u_mid * 0.15;
                vec3 color = vec3(
                    0.5 + 0.5 * cos(hueVal * 6.28),
                    0.5 + 0.5 * cos((hueVal + 0.33) * 6.28),
                    0.5 + 0.5 * cos((hueVal + 0.67) * 6.28)
                );

                float alpha = (edge + fill) * u_intensity;
                gl_FragColor = vec4(color * alpha, alpha);
            }
        `);

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Link error:', gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // Fullscreen quad
    const positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Get uniform locations
    const uniforms = {};
    const uniformNames = [
        'u_time', 'u_resolution', 'u_mouse', 'u_geometry',
        'u_gridDensity', 'u_morphFactor', 'u_chaos', 'u_speed',
        'u_hue', 'u_intensity', 'u_saturation', 'u_dimension',
        'u_rot4dXY', 'u_rot4dXZ', 'u_rot4dYZ',
        'u_rot4dXW', 'u_rot4dYW', 'u_rot4dZW',
        'u_mouseIntensity', 'u_clickIntensity',
        'u_bass', 'u_mid', 'u_high'
    ];
    uniformNames.forEach(name => {
        uniforms[name] = gl.getUniformLocation(program, name);
    });

    // State
    let mouseX = 0.5, mouseY = 0.5, mouseIntensity = 0, clickIntensity = 0;
    let bass = 0, mid = 0, high = 0;
    let audioContext, analyser, dataArray, audioEnabled = false;
    const startTime = performance.now();

    // Mouse tracking
    document.addEventListener('mousemove', e => {
        mouseX = e.clientX / window.innerWidth;
        mouseY = 1 - e.clientY / window.innerHeight;
        mouseIntensity = Math.min(1, mouseIntensity + 0.1);
    });
    document.addEventListener('click', () => {
        clickIntensity = 1;
    });

    // Audio setup
    window.toggleAudio = async function() {
        if (audioEnabled) {
            audioEnabled = false;
            document.querySelector('.audio-btn').textContent = 'ðŸŽµ Enable Audio';
            return;
        }

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioContext = new AudioContext();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            audioEnabled = true;
            document.querySelector('.audio-btn').textContent = 'ðŸ”Š Audio Active';
        } catch (e) {
            console.log('Audio not available:', e);
            alert('Could not access microphone');
        }
    };

    function updateAudio() {
        if (!audioEnabled || !analyser) return;
        analyser.getByteFrequencyData(dataArray);

        // Bass: 0-8, Mid: 8-32, High: 32-64
        let bassSum = 0, midSum = 0, highSum = 0;
        for (let i = 0; i < 8; i++) bassSum += dataArray[i];
        for (let i = 8; i < 32; i++) midSum += dataArray[i];
        for (let i = 32; i < 64; i++) highSum += dataArray[i];

        bass = (bassSum / 8 / 255) * (CONFIG.reactivity?.audio?.sensitivity || 1);
        mid = (midSum / 24 / 255) * (CONFIG.reactivity?.audio?.sensitivity || 1);
        high = (highSum / 32 / 255) * (CONFIG.reactivity?.audio?.sensitivity || 1);
    }

    // Resize
    function resize() {
        const dpr = Math.min(window.devicePixelRatio, 2);
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // Render loop
    function render() {
        const time = performance.now() - startTime;

        updateAudio();
        mouseIntensity *= 0.95;
        clickIntensity *= 0.92;

        gl.uniform1f(uniforms.u_time, time);
        gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);
        gl.uniform2f(uniforms.u_mouse, mouseX, mouseY);
        gl.uniform1f(uniforms.u_geometry, CONFIG.geometry);
        gl.uniform1f(uniforms.u_gridDensity, CONFIG.params.gridDensity);
        gl.uniform1f(uniforms.u_morphFactor, CONFIG.params.morphFactor);
        gl.uniform1f(uniforms.u_chaos, CONFIG.params.chaos);
        gl.uniform1f(uniforms.u_speed, CONFIG.params.speed);
        gl.uniform1f(uniforms.u_hue, CONFIG.params.hue);
        gl.uniform1f(uniforms.u_intensity, CONFIG.params.intensity);
        gl.uniform1f(uniforms.u_saturation, CONFIG.params.saturation || 0.8);
        gl.uniform1f(uniforms.u_dimension, CONFIG.params.dimension || 3.5);
        gl.uniform1f(uniforms.u_rot4dXY, CONFIG.params.rot4dXY || 0);
        gl.uniform1f(uniforms.u_rot4dXZ, CONFIG.params.rot4dXZ || 0);
        gl.uniform1f(uniforms.u_rot4dYZ, CONFIG.params.rot4dYZ || 0);
        gl.uniform1f(uniforms.u_rot4dXW, CONFIG.params.rot4dXW || 0);
        gl.uniform1f(uniforms.u_rot4dYW, CONFIG.params.rot4dYW || 0);
        gl.uniform1f(uniforms.u_rot4dZW, CONFIG.params.rot4dZW || 0);
        gl.uniform1f(uniforms.u_mouseIntensity, mouseIntensity);
        gl.uniform1f(uniforms.u_clickIntensity, clickIntensity);
        gl.uniform1f(uniforms.u_bass, bass);
        gl.uniform1f(uniforms.u_mid, mid);
        gl.uniform1f(uniforms.u_high, high);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }
    render();

    console.log('VIB3+ FACETED visualization initialized');
    console.log('Config:', CONFIG);
    </script>
</body>
</html>